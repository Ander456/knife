
==============================================================================
./knife/base.lua
==============================================================================
   1	return {
    	    extend = function (self, subtype)
  36	        return setmetatable(subtype or {}, {
  18	            __index = self, 
    	            __call = function (self, ...)
   8	                local instance = setmetatable({}, { __index = self }) 
   8	                return instance, instance:constructor(...)
    	            end 
  18	        })
    	    end,
   5	    constructor = function () end,
   1	}
    	

==============================================================================
./knife/event.lua
==============================================================================
    	-- Event module
   1	local Event = {}
    	
    	-- Event handler registry
   1	Event.handlers = {}
    	
    	-- Remove an event handler from the registry
    	local function removeHandler (self)
   3	    if self.prevHandler then
   1	        self.prevHandler.nextHandler = self.nextHandler
    	    end
   3	    if self.nextHandler then
   1	        self.nextHandler.prevHandler = self.prevHandler
    	    end
   3	    if Event.handlers[self.name] == self then
   2	        Event.handlers[self.name] = self.nextHandler
    	    end
   3	    self.prevHandler = nil
   3	    self.nextHandler = nil
    	end
    	
    	-- Create an event handler
    	local function Handler (name, callback)
  15	    return { 
  15	        name = name, 
  15	        callback = callback, 
  15	        remove = removeHandler
  15	    }
    	end
    	
    	-- Insert an event handler into the registry
    	local function register (handler)
  15	    handler.nextHandler = Event.handlers[handler.name]
  15	    if handler.nextHandler then
   5	        handler.nextHandler.prevHandler = handler
    	    end
  15	    Event.handlers[handler.name] = handler
    	    
  15	    return handler
    	end
    	
    	-- Create and register a new event handler
   1	function Event.on (name, callback)
  15	    return register(Handler(name, callback))
    	end
    	
    	-- Dispatch an event
   1	function Event.dispatch (name, ...)
   8	    local handler = Event.handlers[name]
    	    
  15	    while handler do
   8	        if handler.callback(...) == false then 
   1	            return handler
    	        end
   7	        handler = handler.nextHandler
    	    end
    	end
    	
    	-- Inject a dispatcher into a table.
    	local function injectDispatcher (t, key)
    	    t[key] = function (...)
   2	        return Event.dispatch(key, ...)
    	    end
    	end
    	
    	-- Inject dispatchers into a table. Examples:
    	-- Event.injectDispatchers(love.handlers)
    	-- Event.injectDispatchers(love, { 'load', 'update', 'draw' })
   1	function Event.injectDispatchers (t, keys)
   2	    if keys then
   2	        for _, key in ipairs(keys) do
   1	            injectDispatcher(t, key)
    	        end
    	    else
   2	        for key in pairs(t) do 
   1	            injectDispatcher(t, key)
    	        end
    	    end
    	end
    	
   1	return Event
    	

==============================================================================
./knife/memoize.lua
==============================================================================
   1	local loadstring = _G.loadstring or _G.load
   1	local weakKeys = { __mode = 'k' }
   1	local cache = setmetatable({}, weakKeys)
   1	local resultsKey = {}
   1	local nilKey = {}
    	
    	local function getMetaCall (callable)
  64	    local meta = getmetatable(callable)
  64	    return meta and meta.__call
    	end
    	
   1	local tupleConstructorCache = {}
    	
    	local function buildTupleConstructor (n)
  21	    if tupleConstructorCache[n] then
  18	        return tupleConstructorCache[n]
    	    end
   3	    local t = {}
   9	    for i = 1, n do
   6	        t[i] = "a" .. i
    	    end
   3	    local args = table.concat(t, ',')
   6	    local ctor = loadstring('return function(' .. args ..
   6	        ') return function() return ' .. args .. ' end end')()
   3	    tupleConstructorCache[n] = ctor
   3	    return ctor
    	end
    	
    	local function tuple (...)
  21	    return buildTupleConstructor(select('#', ...))(...)
    	end
    	
    	return function (callable)
  54	    local metaCall = getMetaCall(callable)
    	
  54	    if type(callable) ~= 'function' and not metaCall then
   4	        error 'Attempted to memoize a non-callable value.'
    	    end
    	
  50	    cache[callable] = setmetatable({}, weakKeys)
    	
    	    local function run (...)
  45	        local node = cache[callable]
  45	        local argc = select('#', ...)
 116	        for i = 1, argc do
  71	            local key = select(i, ...)
  71	            if key == nil then
   4	                key = nilKey
    	            end
  71	            if not node[key] then
  30	                node[key] = setmetatable({}, weakKeys)
    	            end
  71	            node = node[key]
    	        end
    	
  45	        if not node[resultsKey] then
  22	            node[resultsKey] = tuple(callable(...))
    	        end
    	
  44	        return node[resultsKey]()
    	    end
    	
  50	    if metaCall then
    	        return function (...)
  10	            local call = getMetaCall(callable)
    	
  10	            if call ~= metaCall then
   2	                cache[callable] = setmetatable({}, weakKeys)
   2	                metaCall = call
    	            end
    	
  10	            return run(...)
  16	        end, cache, resultsKey, nilKey
    	    end
    	
  34	    return run, cache, resultsKey, nilKey
    	end

==============================================================================
./knife/system.lua
==============================================================================
   1	local loadstring = _G.loadstring or _G.load
   1	local tremove = table.remove
   1	local tconcat = table.concat
   1	local type = type
    	
   1	local underscoreByteValue = ('_'):byte()
    	
    	local function hasInitialUnderscore (value)
  40	    return type(value) == 'string' and value:byte() == underscoreByteValue
    	end
    	
    	local function checkAspects (entity, aspects)
  20	    for index = 1, #aspects do
  16	        local aspect = aspects[index]
  16	        if entity[aspect] == nil and not hasInitialUnderscore(aspect) then
   4	            return false
    	        end
    	    end
   4	    return true
    	end
    	
    	local function updateRemovalList (list, value, entityIndex)
   4	    if not value then
   3	        return list
    	    end
   1	    if not list then
   1	        list = {}
    	    end
    	
   1	    local valueType = type(value)
    	
   1	    if valueType == 'boolean' then
   1	        list[entityIndex] = true
   1	        return list
    	    end
    	
***0	    if valueType == 'number' then
***0	        list[value] = true
***0	        return list
    	    end
    	
***0	    if valueType == 'table' then
***0	        for i = 1, #value do
***0	            list[value[i]] = true
    	        end
***0	        return list
    	    end
    	
***0	    error 'system returned an invalid value'
    	end
    	
    	local function updateInsertionList (list, value)
   4	    if not value then
   3	        return list
    	    end
   1	    if not list then
   1	        list = {}
    	    end
    	
   1	    list[#list + 1] = value
    	
   1	    return list
    	end
    	
    	local function removeEntities (entities, removalList)
   4	    if not removalList then
   3	        return
    	    end
    	
   3	    for entityIndex = #entities, 1, -1 do
   2	        if removalList[entityIndex] then
   1	            tremove(entities, entityIndex)
    	        end
    	    end
    	end
    	
    	local function createEntities (entities, insertionList)
   4	    if not insertionList then
   3	        return
    	    end
   1	    local entitiesIndex = #entities
    	
   2	    for groupIndex = 1, #insertionList do
   1	        local group = insertionList[groupIndex]
   2	        for newEntityIndex = 1, #group do
   1	            entitiesIndex = entitiesIndex + 1
   1	            entities[entitiesIndex] = group[newEntityIndex]
    	        end
    	    end
    	end
    	
   1	local runningTraversals = 0
    	local removalList
    	local insertionList
    	
    	local function traverse (entities, aspects, process, invoke, ...)
    	
   4	    runningTraversals = runningTraversals + 1
    	
  12	    for index = 1, #entities do
   8	        local entity = entities[index]
   8	        if not entity then
    	            break
    	        end
   8	        if checkAspects(entity, aspects) then
   8	            local removal, insertion = invoke(
   4	                process, entity, entities, index, ...)
    	
   4	            removalList = updateRemovalList(removalList, removal, index)
   4	            insertionList = updateInsertionList(insertionList, insertion)
    	        end
    	    end
    	
   4	    runningTraversals = runningTraversals - 1
    	
   4	    if runningTraversals == 0 then
   4	        removeEntities(entities, removalList)
   4	        createEntities(entities, insertionList)
   4	        removalList = nil
   4	        insertionList = nil
    	    end
    	end
    	
    	local function generateProcessInvoker (aspects)
  16	    local args = {}
    	
  52	    for index = 1, #aspects do
  36	        local aspect = aspects[index]
  36	        if hasInitialUnderscore(aspect) then
   8	            args[index] = aspect
    	        else
  28	            args[index] = ('_entity[%q]'):format(aspect)
    	        end
    	    end
    	
    	    local source
    	    local template = [[
    	        return function (_process, _entity, _entities, _index, ...)
    	            return _process(%s ...)
    	        end
  16	    ]]
    	
  16	    if args[1] then
  16	        source = (template):format(tconcat(args, ', ') .. ', ')
    	    else
***0	        source = (template):format('')
    	    end
    	
  16	    return loadstring(source)()
    	end
    	
    	return function (aspects, process)
  16	    local invoke = generateProcessInvoker(aspects)
    	    return function (entities, ...)
   4	        return traverse(entities, aspects, process, invoke, ...)
    	    end
    	end

==============================================================================
./knife/test.lua
==============================================================================
    	local test, testAssert, testError
    	
    	-- Create a node representing a test section
    	local function createNode (parent, description, process)
 106	    return setmetatable({
  53	        parent = parent,
  53	        description = description,
  53	        process = process,
  53	        nodes = {},
  53	        activeNodeIndex = 1,
  53	        currentNodeIndex = 0,
  53	        assert = testAssert,
  53	        error = testError,
 106	    }, { __call = test })
    	end
    	
    	-- Run a node
    	local function runNode (node)
 134	    node.currentNodeIndex = 0
 134	    return node:process()
    	end
    	
    	-- Get the root node for a given node
    	local function getRootNode (node) 
 125	    local parent = node.parent
 125	    return parent and getRootNode(parent) or node
    	end
    	
    	-- Update the active child node of the given node
    	local function updateActiveNode (node, description, process) 
  81	    local activeNodeIndex = node.activeNodeIndex
  81	    local nodes = node.nodes
  81	    local activeNode = nodes[activeNodeIndex]
    	
  81	    if not activeNode then
  46	        activeNode = createNode(node, description, process)
  46	        nodes[activeNodeIndex] = activeNode
    	    else 
  35	        activeNode.process = process
    	    end
    	    
  81	    getRootNode(node).lastActiveLeaf = activeNode
    	
  81	    return activeNode
    	end
    	
    	-- Run the active child node of the given node
    	local function runActiveNode (node, description, process) 
  81	    local activeNode = updateActiveNode(node, description, process)
  81	    return runNode(activeNode)
    	end
    	
    	-- Get ancestors of a node, including the node
   1	function getAncestors (node)
   2	    local ancestors = { node }
  14	    for ancestor in function () return node.parent end do
   5	        ancestors[#ancestors + 1] = ancestor
   5	        node = ancestor
    	    end
   2	    return ancestors
    	end
    	
    	-- Print a message describing one execution path in the test scenario
    	local function printScenario (node) 
   2	    local ancestors = getAncestors(node)
   9	    for i = #ancestors, 1, -1 do
   7	        io.stderr:write(ancestors[i].description or '')
   7	        io.stderr:write('\n')
    	    end
    	end
    	
    	-- Print a message and stop the test scenario when an assertion fails
    	local function failAssert (node, description, message)
   2	    io.stderr:write(message or '')
   2	    io.stderr:write('\n\n')
   2	    printScenario(node)
   2	    io.stderr:write(description or '')
   2	    io.stderr:write('\n\n')
   2	    error(message or '')
    	end
    	
    	-- Create a branch node for a test scenario
    	test = function (node, description, process) 
 344	    node.currentNodeIndex = node.currentNodeIndex + 1
 344	    if node.currentNodeIndex == node.activeNodeIndex then
  81	        return runActiveNode(node, description, process) 
    	    end
    	end
    	
    	-- Test an assertion
    	testAssert = function (self, value, description)
 164	    if not value then
   1	        return failAssert(self, description, 'Test failed: assertion failed')
    	    end
 163	    return value
    	end
    	
    	-- Expect function f to fail
    	testError = function (self, f, description)
  14	    if pcall(f) then
   1	        return failAssert(self, description, 'Test failed: expected error')
    	    end
    	end
    	
    	-- Create the root node for a test scenario
    	local function T (description, process)
   7	    local root = createNode(nil, description, process)
    	    
   7	    runNode(root)
  53	    while root.activeNodeIndex <= #root.nodes do
  46	        local lastActiveBranch = root.lastActiveLeaf.parent
  46	        lastActiveBranch.activeNodeIndex = lastActiveBranch.activeNodeIndex + 1
  46	        runNode(root)
    	    end
    	    
   7	    return root
    	end
    	
    	-- Run any other files passed from CLI.
   1	if arg and arg[0]:gmatch('test.lua') then
   1	    _G.T = T
   6	    for i = 1, #arg do
   5	        dofile(arg[i])
    	    end
   1	    _G.T = nil
    	end
    	
   1	return T
    	

==============================================================================
./spec/base.lua
==============================================================================
    	local function checkSubSuper (T, Sub, Super)
  52	  T:assert(getmetatable(Sub).__index == Super, 
  26	  'Then the super is the index for the sub')
  52	  T:assert(Sub ~= Super,
  26	  'Then the super is not identical to the sub')
    	end
    	
    	local function checkNotCallable (T, instance)
  24	  T:error(function () instance() end, 
   8	  'Then the instance is not callable')
    	end
    	
    	local function checkConstruct (T, Class)
  36	  T('When instantiated with the default constructor', 
    	  function (T)
   4	    Class.constructor = nil
   4	    local c = Class()
   4	    checkSubSuper(T, c, Class)
   4	    checkNotCallable (T, c)
    	  end)
  36	  T('When instantiated with a custom constructor', 
    	  function (T)
   8	    function Class:constructor (x) self.x = x; return x, 45 end
   4	    local c, x, y = Class(123)
   8	    T:assert(c.x == 123,
   4	    'Then the constructor is applied to the instance')
   8	    T:assert(x == 123 and y == 45,
   4	    'Then return values from the constructor follow the instance')
   4	    checkSubSuper(T, c, Class)
   4	    checkNotCallable (T, c)
    	  end)
    	end
    	
    	local function checkExtend (T, Class)
  24	  T('When a class is extended', 
    	  function (T)
   6	    local Sub = Class:extend()
   6	    checkSubSuper(T, Sub, Class)
   6	    checkConstruct(T, Sub)
    	  end)
    	end
    	
   2	T('Given a base class', 
    	function (T)
  13	  local Base = require 'knife.base'
  26	  T('When the base class is extended with no arguments', 
    	  function (T)
   6	    local Thing = Base:extend()
   6	    checkSubSuper(T, Thing, Base)
   6	    checkConstruct(T, Thing)
   6	    checkExtend (T, Thing)
    	  end)
  26	  T('When the base class is extended with a table argument', 
    	  function (T)
   6	    local t = { x = 1 }
   6	    local Thing = Base:extend(t)
  12	    T:assert(Thing == t,
   6	    'Then the new class is identical to the table')
   6	    checkSubSuper(T, Thing, Base)
   6	    checkConstruct(T, Thing)
   6	    checkExtend (T, Thing)
    	  end)
    	end)
    	

==============================================================================
./spec/event.lua
==============================================================================
   2	T('Given event module is loaded', function (T)
  11	    local Event = require 'knife.event'
  11	    Event.handlers = {}
    	    
  22	    T('When a handler is registered', function (T)
    	        local eventArg
  11	        local fooHandler = Event.on('foo', function (x) eventArg = x end)
    	        
  16	        T('When the event fires', function (T)
   1	            assert(eventArg == nil)
   1	            Event.dispatch('foo', 123)
   1	            T:assert(eventArg == 123, 'Then the handler runs')
    	        end)
    	        
  16	        T('When the handler is removed and the event fires', function (T)
   1	            fooHandler:remove()
   1	            assert(eventArg == nil)
   1	            Event.dispatch('foo', 123)
   1	            T:assert(eventArg == nil, 'Then the handler does not run')
    	        end)
    	            
  16	        T('When a second handler is registered', function (T)
    	            local eventArg2
   6	            local fooHandler2 = Event.on('foo', function (x) eventArg2 = x end)
    	            
   8	            T('When the event fires', function (T)
   1	                assert(eventArg == nil and eventArg2 == nil)
   1	                Event.dispatch('foo', 123)
   1	                T:assert(eventArg == 123, 'Then the first handler runs')
   1	                T:assert(eventArg2 == 123, 'Then the second handler runs')
    	            end)
    	            
   8	            T('When the first handler is removed and the event fires', function (T)
   1	                fooHandler:remove()
   1	                assert(eventArg == nil and eventArg2 == nil)
   1	                Event.dispatch('foo', 123)
   1	                T:assert(eventArg == nil, 'Then the first handler does not run')
   1	                T:assert(eventArg2 == 123, 'Then the second handler runs')
    	            end)
    	            
   8	            T('When the second handler is removed and the event fires', function (T)
   1	                fooHandler2:remove()
   1	                assert(eventArg == nil and eventArg2 == nil)
   1	                Event.dispatch('foo', 123)
   1	                T:assert(eventArg == 123, 'Then the first handler runs')
   1	                T:assert(eventArg2 == nil, 'Then the second handler does not run')
    	            end)
    	            
    	        end)
    	        
  16	        T('When a second handler returning false is registered', function (T)
    	            local eventArg2
   2	            Event.on('foo', function (x) 
   1	                eventArg2 = x
   1	                return false 
    	            end)
   1	            assert(eventArg == nil and eventArg2 == nil)
   1	            Event.dispatch('foo', 123)
   1	            T:assert(eventArg == nil, 'Then the first handler does not run')
   1	            T:assert(eventArg2 == 123, 'Then the second handler runs')
    	        end)
    	        
    	    end)
    	    
  22	    T('When dispatchers are injected into a table', function (T)
   1	        local t = { bar = true }
    	        local eventArg
   1	        Event.injectDispatchers(t)
   2	        Event.on('bar', function (x) eventArg = x end)
   1	        assert(eventArg == nil)
   1	        t.bar(123)
   1	        T:assert(eventArg == 123, 'Then members of the table dispatch events')
    	    end)
    	    
  22	    T('When dispatchers are injected into a table by key', function (T)
   1	        local t = {}
    	        local eventArg
   1	        Event.injectDispatchers(t, { 'baz' })
   2	        Event.on('baz', function (x) eventArg = x end)
   1	        assert(eventArg == nil)
   1	        t.baz(123)
   1	        T:assert(eventArg == 123, 'Then members of the table dispatch events')
    	    end)
    	    
    	end)

==============================================================================
./spec/memoize.lua
==============================================================================
   2	T('memoize', 
    	function (T)
    	    
  15	  local memoize = require 'knife.memoize'
    	
  15	  local counter = 0
    	
    	  local function count(...)
  12	    counter = counter + 1
  12	    return counter
    	  end
    	
  15	  local memoized_count = memoize(count)
    	
    	  local function switch(x,y)
   2	    counter = counter + 1
   2	    return y,x
    	  end
    	
  15	  local memoized_switch = memoize(switch)
    	
  15	  local countable = setmetatable({}, {__call = count})
  15	  local memoized_countable = memoize(countable)
    	
    	  local function count2(...)
   1	    counter = counter + 1
   1	    return counter
    	  end
    	
  30	  T("should accept ony non-callable parameters, and error otherwise", 
    	  function (T)
   2	    T:error(function() memoize() end)
   2	    T:error(function() memoize('foo') end)
   2	    T:error(function() memoize(1) end)
   2	    T:error(function() memoize({}) end)
   1	    memoize(print)
   1	    memoize(countable)
    	  end)
  30	  T("should work with 0 parameters", 
    	  function (T)
   1	    memoized_count()
   1	    T:assert(memoized_count() == 1)
   1	    T:assert(counter == 1)
    	  end)
    	
  30	  T("should work with one parameter", 
    	  function (T)
   1	    memoized_count('foo')
   1	    T:assert(memoized_count('foo') == 1)
   1	    T:assert(memoized_count('bar') == 2)
   1	    T:assert(memoized_count('foo') == 1)
   1	    T:assert(memoized_count('bar') == 2)
   1	    T:assert(counter == 2)
    	  end)
    	
  30	  T("should work with two parameters", 
    	  function (T)
   1	    memoized_count('foo', 'bar')
   1	    T:assert(memoized_count('foo', 'bar') == 1, '1')
   1	    T:assert(memoized_count('foo', 'baz') == 2, '2')
   1	    T:assert(memoized_count('foo', 'bar') == 1, '3')
   1	    T:assert(memoized_count('foo', 'baz') == 2, '4')
   1	    T:assert(counter == 2)
    	  end)
    	
  30	  T("should work with tables & functions", 
    	  function (T)
   1	    local t1 = {}
   1	    local t2 = {}
   1	    T:assert(memoized_count(print, t1) == 1)
   1	    T:assert(memoized_count(print, t2) == 2)
   1	    T:assert(memoized_count(print, t1) == 1)
   1	    T:assert(memoized_count(print, t2) == 2)
   1	    T:assert(counter == 2)
    	  end)
    	
  30	  T("should return multiple values when needed", 
    	  function (T)
   1	    local x,y = memoized_switch(100, 200)
   1	    T:assert(x == 200)
   1	    T:assert(y == 100)
   1	    T:assert(counter == 1)
   1	    x,y = memoized_switch(400, 500)
   1	    T:assert(x == 500)
   1	    T:assert(y == 400)
   1	    T:assert(counter == 2)
   1	    x,y = memoized_switch(100, 200)
   1	    T:assert(x == 200)
   1	    T:assert(y == 100)
   1	    T:assert(counter == 2)
   1	    x,y = memoized_switch(400, 500)
   1	    T:assert(x == 500)
   1	    T:assert(y == 400)
   1	    T:assert(counter == 2)
    	  end)
    	
  30	  T("should clean cache when called twice", 
    	  function (T)
   1	    memoized_count('reset')
   1	    T:assert(memoized_count('reset') == 1)
   1	    memoize(count)
   1	    T:assert(memoized_count('reset') == 2)
    	  end)
    	
  30	  T( 'callable tables', 
    	  function (T)
    	    
   8	    T("Unchanged callable tables should work just like functions", 
    	    function (T)
   1	      memoized_countable()
   1	      T:assert(memoized_countable() == 1)
   1	      T:assert(counter == 1)
   1	      memoized_countable('foo')
   1	      T:assert(memoized_countable('foo') == 2)
   1	      T:assert(counter == 2)
    	    end)
    	
   8	    T("When callable table's __call metamethod is changed, the cache is reset", 
    	    function (T)
   1	      memoized_countable('bar')
   1	      T:assert(memoized_countable('bar') == 1)
   1	      local mt = getmetatable(countable)
   1	      mt.__call = count2
   1	      memoized_countable('bar')
   1	      T:assert(memoized_countable('bar') == 2)
   1	      T:assert(memoized_countable('bar') == 2)
    	    end)
    	
   8	    T("An error is thrown if a memoized callable table loses its __call", 
    	    function (T)
   1	      local mt = getmetatable(countable)
   1	      mt.__call = nil
   2	      T:error(function() memoized_countable() end)
    	    end)
    	  end)
    	  
  30	  T("airstruck", 
    	  function (T)
    	  
   6	      T("handles nil arguments", 
    	      function (T)
    	  
    	        local function cat(a, b, c)
   4	          return tostring(a) .. tostring(b) .. tostring(c)
    	        end
    	
   1	        local memoized_cat = memoize(cat)
    	        
   1	        T:assert(memoized_cat('a', 'b', 'c') == 'abc', '1')
   1	        T:assert(memoized_cat('a', 'b', 'c') == 'abc', '2')
    	        
   1	        T:assert(memoized_cat('va', nil, 'la') == 'vanilla', '3')
   1	        T:assert(memoized_cat('va', nil, 'la') == 'vanilla', '4')
    	        
   1	        T:assert(memoized_cat('va', 'la') == 'valanil', '5')
   1	        T:assert(memoized_cat('va', 'la') == 'valanil', '6')
    	        
   1	        T:assert(memoized_cat('va') == 'vanilnil', '7')
   1	        T:assert(memoized_cat('va') == 'vanilnil', '8')
    	        
    	      end)
    	      
   6	      T("handles nil results", 
    	      function (T)
    	      
    	        local function passthrough (a, b, c)
   2	          return a, b, c
    	        end
    	
   1	        local memoized_passthrough = memoize(passthrough)
    	      
   1	        local a, b, c = memoized_passthrough('a', 'b', 'c')
   1	        T:assert(a == 'a') T:assert(b == 'b') T:assert(c == 'c')
    	        
   1	        a, b, c = memoized_passthrough('a', 'b', 'c')
   1	        T:assert(a == 'a') T:assert(b == 'b') T:assert(c == 'c')
    	        
   1	        x, y, z = memoized_passthrough('x', nil, 'z')
   1	        T:assert(x == 'x') T:assert(y == nil) T:assert(z == 'z')
    	        
   1	        x, y, z = memoized_passthrough('x', nil, 'z')
   1	        T:assert(x == 'x') T:assert(y == nil) T:assert(z == 'z')
    	        
    	      end)
    	      
    	  end)
    	
    	end)
    	

==============================================================================
./spec/system.lua
==============================================================================
   2	T('Given some systems and some entities',
    	function (T)
   4	    local System = require 'knife.system'
    	
   4	    local e1 = {
   4	        position = { x = 10, y = 20 },
    	    }
   4	    local e2 = {
   4	        position = { x = 30, y = 40 },
   4	        velocity = { x = 1, y = 2 }
    	    }
   4	    local e3 = {
   4	        position = { x = 1, y = 2 },
   4	        velocity = { x = 2, y = 1 }
    	    }
    	
   8	    local updatePosition = System(
   4	    { 'position', 'velocity' },
    	    function (pos, vel)
   2	        pos.x = pos.x + vel.x
   2	        pos.y = pos.y + vel.y
    	    end)
    	
   8	    local updateBoundary = System(
   4	    { 'position', 'velocity' },
    	    function (pos, vel)
   1	        if pos.y > 40 then
   1	            return true
    	        end
    	    end)
    	
   8	    local addStuff = System(
   4	    { 'position', 'velocity' },
    	    function (pos, vel)
   1	        return false, { e3 }
    	    end)
    	
   8	    local manualRemove = System(
   4	    { 'position', '_index', '_entities' },
    	    function (pos, i, e)
***0	        if i == 1 then
***0	            table.remove(e, i)
    	        end
    	    end)
    	
   4	    local entities = { e1, e2 }
    	
   8	    T('When a system is invoked',
    	    function (T)
   1	        updatePosition(entities)
   2	        T:assert(entities[2].position.y == 42,
   1	        'Then the components of the entities are updated')
    	    end)
    	
   8	    T('When a process returns a truthy value',
    	    function (T)
   1	        assert(#entities == 2)
   1	        updatePosition(entities)
   1	        updateBoundary(entities)
   2	        T:assert(#entities == 1 and entities[1] == e1,
   1	        'Then the current entity is removed')
    	    end)
    	
   8	    T('When a process returns new entities',
    	    function (T)
   1	        assert(#entities == 2)
   1	        addStuff(entities)
   2	        T:assert(entities[3] == e3,
   1	        'Then the new entities are added')
    	    end)
    	
    	end)

==============================================================================
./spec/test.lua
==============================================================================
   2	T('Given an empty table', 
    	function (T)
   6	  local t = {}
  12	  T('When an item is inserted into a table', 
    	  function (T)
   5	    assert(#t == 0)
   5	    table.insert(t, 111)
   5	    T:assert(#t == 1, 'Then the size of the table is 1')
   5	    T:assert(t[1] == 111, 'Then the item is stored in index 1')
    	    
  10	    T('When the index is set to nil', 
    	    function (T)
   1	      assert(#t == 1)
   1	      t[1] = nil
   1	      T:assert(#t == 0, 'Then the size of the table is 0')
   2	        pcall(function ()
   2	            T:error(function () end, 'THIS TEST INTENTIONALLY FAILS')
    	        end)
    	    end)
    	    
  10	    T('When another item is inserted', 
    	    function (T)
   3	      assert(#t == 1)
   3	      table.insert(t, 222)
   3	      T:assert(#t == 2, 'Then the size of the table is 2')
   3	      T:assert(t[2] == 222, 'Then the second item is stored in index 2')
    	
   6	      T('When the first item is removed with table.remove', 
    	      function (T)
   1	        assert(#t == 2)
   1	        table.remove(t, 1)
   1	        T:assert(#t == 1, 'Then the size of the table is 1')
   1	        T:assert(t[1] == 222, 'Then the second item has moved to index 1')
    	      end)
    	      
   6	      T('When the first item is set to nil', 
    	      function (T)
   1	        assert(#t == 2)
   1	        t[1] = nil
   1	        T:assert(#t == 2, 'Then the size of the table is 2')
   1	        T:assert(t[2] == 222, 'Then the second item remains in index 2')
   2	        pcall(function () 
   1	            T:assert(false, 'THIS TEST INTENTIONALLY FAILS') 
    	        end)
    	      end)
    	    end)
    	    
    	  end)
    	end)
    	
   2	T('Given a value of two', function (T)
   3	  local value = 2
   6	  T('When the value is increased by five', function (T)
    	    -- here, value is 2
   1	    value = value + 5
   1	    local foo = 10
   1	    T:assert(value == 7 and foo == 10, 'Then the value equals seven')
    	  end)
   6	  T('When the value is decreased by five', function (T)
    	    -- value is 2 again; this test is isolated from the "increased by five" test
   1	    value = value - 5
   1	    T:assert(value == -3, 'Then the value equals negative three')
    	  end)
    	end)
    	
   2	T('Given a value of two', function (T)
   1	  local value = 2
   1	  T:assert(value == 2, 'Then the value equals two')
    	end)

==============================================================================
Summary
==============================================================================

8	0	100.00%	./knife/base.lua
36	0	100.00%	./knife/event.lua
43	0	100.00%	./knife/memoize.lua
66	9	88.00%	./knife/system.lua
62	0	100.00%	./knife/test.lua
39	0	100.00%	./spec/base.lua
55	0	100.00%	./spec/event.lua
111	0	100.00%	./spec/memoize.lua
39	2	95.12%	./spec/system.lua
42	0	100.00%	./spec/test.lua
------------------------
501	11	97.85%	
