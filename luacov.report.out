
==============================================================================
./knife/base.lua
==============================================================================
   1	return {
    	    extend = function (self, subtype)
  36	        return setmetatable(subtype or {}, {
  18	            __index = self, 
    	            __call = function (self, ...)
   8	                local instance = setmetatable({}, { __index = self }) 
   8	                return instance, instance:constructor(...)
    	            end 
  18	        })
    	    end,
   5	    constructor = function () end,
   1	}
    	

==============================================================================
./knife/behavior.lua
==============================================================================
    	-- behavior.lua -- a state manager
    	
    	-- internal/external api
    	
    	local function getCurrentFrame (behavior)
  18	    return behavior.states[behavior.state][behavior.index]
    	end
    	
    	local function advanceFrame (behavior)
  12	    local nextState = behavior.frame.after
  12	    local nextIndex = behavior.index + 1
  12	    local maxIndex = #behavior.states[behavior.state]
    	
  12	    if nextState then
   2	        behavior.state = nextState
   2	        nextIndex = 1
  10	    elseif nextIndex > maxIndex then
   2	        nextIndex = 1
    	    end
    	
  12	    behavior.index = nextIndex
  12	    behavior.frame = behavior:getCurrentFrame()
    	end
    	
    	local function performAction (behavior)
  18	    local act = behavior.frame.action
    	
  18	    if act then
   2	        act(behavior, behavior.subject)
    	    end
    	end
    	
    	-- external api
    	
    	local function update (behavior, dt)
   3	    behavior.elapsed = behavior.elapsed + dt
    	
  15	    while behavior.elapsed >= behavior.frame.duration do
  12	        behavior.elapsed = behavior.elapsed - behavior.frame.duration
  12	        behavior:advanceFrame()
  12	        behavior:performAction()
    	    end
    	
   3	    return behavior
    	end
    	
    	local function setState (behavior, state, index)
   1	    behavior.state = state
   1	    behavior.index = index or 1
   1	    behavior.elapsed = 0
   1	    behavior.frame = behavior:getCurrentFrame()
   1	    behavior:performAction()
   1	    return behavior
    	end
    	
    	-- behavior factory
    	
    	return function (states, subject)
   5	    local behavior = {
   5	        states = states,
   5	        subject = subject,
   5	        elapsed = 0,
   5	        state = 'default',
   5	        index = 1,
    	        -- internal api
   5	        getCurrentFrame = getCurrentFrame,
   5	        advanceFrame = advanceFrame,
   5	        performAction = performAction,
    	        -- external api
   5	        update = update,
   5	        setState = setState
    	    }
    	
   5	    behavior.frame = behavior:getCurrentFrame()
   5	    behavior:performAction()
    	
   5	    return behavior
    	end

==============================================================================
./knife/chain.lua
==============================================================================
    	local function getNextLink (callbacks)
    	
    	    local function getCallbackInvoker (index)
    	        return function (...)
   3	            local callback = callbacks[index]
   3	            if not callback then
   1	                return
    	            end
   2	            callback(getCallbackInvoker(index + 1), ...)
    	        end
    	    end
    	
    	    local function nextLink (callback, ...)
   3	        if not callback then
   1	            return getCallbackInvoker(1)(...)
    	        end
   2	        callbacks[#callbacks + 1] = callback
   2	        return nextLink
    	    end
    	
   3	    return nextLink
    	end
    	
    	return function (callback)
   3	    local callbacks = { callback }
   3	    return getNextLink(callbacks)
    	end

==============================================================================
./knife/convoke.lua
==============================================================================
    	return function (routine)
   4	    local routines = { routine }
   4	    local routineIndex = 1
   4	    local isFinished = false
    	
    	    local function execute ()
   5	        local continueCount = 0
    	        local run
    	
    	        local function continue ()
   8	            continueCount = continueCount + 1
    	            return function (...)
   8	                continueCount = continueCount - 1
   8	                if continueCount == 0 then
   7	                    return run(...)
    	                end
    	            end
    	        end
    	
    	        local function wait (...)
   7	            return coroutine.yield(...)
    	        end
    	
  10	        local r = coroutine.create(function ()
   5	            isFinished = false
  11	            while routineIndex <= #routines do
   6	                routines[routineIndex](continue, wait)
   6	                continueCount = 0
   6	                routineIndex = routineIndex + 1
    	            end
   5	            isFinished = true
    	        end)
    	
    	        run = function (...)
  12	            return coroutine.resume(r, ...)
    	        end
    	
   5	        run()
    	    end
    	
    	    local function appendOrExecute (routine)
   6	        if routine then
   2	            routines[#routines + 1] = routine
   2	            if isFinished then
   1	                execute()
    	            end
   2	            return appendOrExecute
    	        else
   4	            execute()
    	        end
    	    end
    	
   4	    return appendOrExecute
    	end

==============================================================================
./knife/event.lua
==============================================================================
    	-- Event module
   1	local Event = {}
    	
    	-- Event handler registry
   1	Event.handlers = {}
    	
    	-- Remove an event handler from the registry
    	local function removeHandler (self)
   3	    if self.prevHandler then
   1	        self.prevHandler.nextHandler = self.nextHandler
    	    end
   3	    if self.nextHandler then
   1	        self.nextHandler.prevHandler = self.prevHandler
    	    end
   3	    if Event.handlers[self.name] == self then
   2	        Event.handlers[self.name] = self.nextHandler
    	    end
   3	    self.prevHandler = nil
   3	    self.nextHandler = nil
    	end
    	
    	-- Create an event handler
    	local function Handler (name, callback)
  15	    return { 
  15	        name = name, 
  15	        callback = callback, 
  15	        remove = removeHandler
  15	    }
    	end
    	
    	-- Insert an event handler into the registry
    	local function register (handler)
  15	    handler.nextHandler = Event.handlers[handler.name]
  15	    if handler.nextHandler then
   5	        handler.nextHandler.prevHandler = handler
    	    end
  15	    Event.handlers[handler.name] = handler
    	    
  15	    return handler
    	end
    	
    	-- Create and register a new event handler
   1	function Event.on (name, callback)
  15	    return register(Handler(name, callback))
    	end
    	
    	-- Dispatch an event
   1	function Event.dispatch (name, ...)
   8	    local handler = Event.handlers[name]
    	    
  15	    while handler do
   8	        if handler.callback(...) == false then 
   1	            return handler
    	        end
   7	        handler = handler.nextHandler
    	    end
    	end
    	
    	-- Inject a dispatcher into a table.
    	local function injectDispatcher (t, key)
    	    t[key] = function (...)
   2	        return Event.dispatch(key, ...)
    	    end
    	end
    	
    	-- Inject dispatchers into a table. Examples:
    	-- Event.injectDispatchers(love.handlers)
    	-- Event.injectDispatchers(love, { 'load', 'update', 'draw' })
   1	function Event.injectDispatchers (t, keys)
   2	    if keys then
   2	        for _, key in ipairs(keys) do
   1	            injectDispatcher(t, key)
    	        end
    	    else
   2	        for key in pairs(t) do 
   1	            injectDispatcher(t, key)
    	        end
    	    end
    	end
    	
   1	return Event
    	

==============================================================================
./knife/memoize.lua
==============================================================================
   1	local loadstring = _G.loadstring or _G.load
   1	local weakKeys = { __mode = 'k' }
   1	local cache = setmetatable({}, weakKeys)
   1	local resultsKey = {}
   1	local nilKey = {}
    	
    	local function getMetaCall (callable)
  64	    local meta = getmetatable(callable)
  64	    return meta and meta.__call
    	end
    	
   1	local tupleConstructorCache = {}
    	
    	local function buildTupleConstructor (n)
  21	    if tupleConstructorCache[n] then
  18	        return tupleConstructorCache[n]
    	    end
   3	    local t = {}
   9	    for i = 1, n do
   6	        t[i] = "a" .. i
    	    end
   3	    local args = table.concat(t, ',')
   6	    local ctor = loadstring('return function(' .. args ..
   6	        ') return function() return ' .. args .. ' end end')()
   3	    tupleConstructorCache[n] = ctor
   3	    return ctor
    	end
    	
    	local function tuple (...)
  21	    return buildTupleConstructor(select('#', ...))(...)
    	end
    	
    	return function (callable)
  54	    local metaCall = getMetaCall(callable)
    	
  54	    if type(callable) ~= 'function' and not metaCall then
   4	        error 'Attempted to memoize a non-callable value.'
    	    end
    	
  50	    cache[callable] = setmetatable({}, weakKeys)
    	
    	    local function run (...)
  45	        local node = cache[callable]
  45	        local argc = select('#', ...)
 116	        for i = 1, argc do
  71	            local key = select(i, ...)
  71	            if key == nil then
   4	                key = nilKey
    	            end
  71	            if not node[key] then
  30	                node[key] = setmetatable({}, weakKeys)
    	            end
  71	            node = node[key]
    	        end
    	
  45	        if not node[resultsKey] then
  22	            node[resultsKey] = tuple(callable(...))
    	        end
    	
  44	        return node[resultsKey]()
    	    end
    	
  50	    if metaCall then
    	        return function (...)
  10	            local call = getMetaCall(callable)
    	
  10	            if call ~= metaCall then
   2	                cache[callable] = setmetatable({}, weakKeys)
   2	                metaCall = call
    	            end
    	
  10	            return run(...)
  16	        end, cache, resultsKey, nilKey
    	    end
    	
  34	    return run, cache, resultsKey, nilKey
    	end

==============================================================================
./knife/system.lua
==============================================================================
   1	local loadstring = _G.loadstring or _G.load
   1	local tremove = table.remove
   1	local tconcat = table.concat
   1	local type = type
    	
   1	local underscoreByteValue = ('_'):byte()
   1	local runningTraversals = 0
    	local removalList
    	local insertionList
    	
    	local function hasInitialUnderscore (value)
  48	    return type(value) == 'string' and value:byte() == underscoreByteValue
    	end
    	
    	local function checkAspects (entity, aspects)
  36	    for index = 1, #aspects do
  23	        local aspect = aspects[index]
  23	        if entity[aspect] == nil and not hasInitialUnderscore(aspect) then
   4	            return false
    	        end
    	    end
  13	    return true
    	end
    	
    	local function updateRemovalList (list, value, entityIndex)
  13	    if not value then
   7	        return list
    	    end
   6	    if not list then
   4	        list = {}
    	    end
    	
   6	    local valueType = type(value)
    	
   6	    if valueType == 'boolean' then
   1	        list[entityIndex] = true
   1	        return list
    	    end
    	
   5	    if valueType == 'number' then
   2	        list[value] = true
   2	        return list
    	    end
    	
   3	    if valueType == 'table' then
   6	        for i = 1, #value do
   4	            list[value[i]] = true
    	        end
   2	        return list
    	    end
    	
   1	    runningTraversals = 0
   1	    removalList = nil
   1	    insertionList = nil
    	
   1	    error 'system returned an invalid value'
    	end
    	
    	local function updateInsertionList (list, value)
  12	    if not value then
  11	        return list
    	    end
   1	    if not list then
   1	        list = {}
    	    end
    	
   1	    list[#list + 1] = value
    	
   1	    return list
    	end
    	
    	local function removeEntities (entities, removalList)
   8	    if not removalList then
   5	        return
    	    end
    	
   9	    for entityIndex = #entities, 1, -1 do
   6	        if removalList[entityIndex] then
   4	            tremove(entities, entityIndex)
    	        end
    	    end
    	end
    	
    	local function createEntities (entities, insertionList)
   8	    if not insertionList then
   7	        return
    	    end
   1	    local entitiesIndex = #entities
    	
   2	    for groupIndex = 1, #insertionList do
   1	        local group = insertionList[groupIndex]
   2	        for newEntityIndex = 1, #group do
   1	            entitiesIndex = entitiesIndex + 1
   1	            entities[entitiesIndex] = group[newEntityIndex]
    	        end
    	    end
    	end
    	
    	local function traverse (entities, aspects, process, invoke, ...)
    	
   9	    runningTraversals = runningTraversals + 1
    	
  25	    for index = 1, #entities do
  17	        local entity = entities[index]
  17	        if not entity then
    	            break
    	        end
  17	        if checkAspects(entity, aspects) then
  26	            local removal, insertion = invoke(
  13	                process, entity, entities, index, ...)
    	
  13	            removalList = updateRemovalList(removalList, removal, index)
  12	            insertionList = updateInsertionList(insertionList, insertion)
    	        end
    	    end
    	
   8	    runningTraversals = runningTraversals - 1
    	
   8	    if runningTraversals == 0 then
   8	        removeEntities(entities, removalList)
   8	        createEntities(entities, insertionList)
   8	        removalList = nil
   8	        insertionList = nil
    	    end
    	end
    	
    	local function generateProcessInvoker (aspects)
  24	    local args = {}
    	
  66	    for index = 1, #aspects do
  42	        local aspect = aspects[index]
  42	        if hasInitialUnderscore(aspect) then
   1	            args[index] = aspect
    	        else
  41	            args[index] = ('_entity[%q]'):format(aspect)
    	        end
    	    end
    	
    	    local source
    	    local template = [[
    	        return function (_process, _entity, _entities, _index, ...)
    	            return _process(%s ...)
    	        end
  24	    ]]
    	
  24	    if args[1] then
  23	        source = (template):format(tconcat(args, ', ') .. ', ')
    	    else
   1	        source = (template):format('')
    	    end
    	
  24	    return loadstring(source)()
    	end
    	
    	return function (aspects, process)
  24	    local invoke = generateProcessInvoker(aspects)
    	    return function (entities, ...)
   9	        return traverse(entities, aspects, process, invoke, ...)
    	    end
    	end

==============================================================================
./knife/test.lua
==============================================================================
    	local test, testAssert, testError
    	
    	-- Create a node representing a test section
    	local function createNode (parent, description, process)
 146	    return setmetatable({
  73	        parent = parent,
  73	        description = description,
  73	        process = process,
  73	        nodes = {},
  73	        activeNodeIndex = 1,
  73	        currentNodeIndex = 0,
  73	        assert = testAssert,
  73	        error = testError,
 146	    }, { __call = test })
    	end
    	
    	-- Run a node
    	local function runNode (node)
 178	    node.currentNodeIndex = 0
 178	    return node:process()
    	end
    	
    	-- Get the root node for a given node
    	local function getRootNode (node) 
 157	    local parent = node.parent
 157	    return parent and getRootNode(parent) or node
    	end
    	
    	-- Update the active child node of the given node
    	local function updateActiveNode (node, description, process) 
 105	    local activeNodeIndex = node.activeNodeIndex
 105	    local nodes = node.nodes
 105	    local activeNode = nodes[activeNodeIndex]
    	
 105	    if not activeNode then
  63	        activeNode = createNode(node, description, process)
  63	        nodes[activeNodeIndex] = activeNode
    	    else 
  42	        activeNode.process = process
    	    end
    	    
 105	    getRootNode(node).lastActiveLeaf = activeNode
    	
 105	    return activeNode
    	end
    	
    	-- Run the active child node of the given node
    	local function runActiveNode (node, description, process) 
 105	    local activeNode = updateActiveNode(node, description, process)
 105	    return runNode(activeNode)
    	end
    	
    	-- Get ancestors of a node, including the node
   1	function getAncestors (node)
   2	    local ancestors = { node }
  14	    for ancestor in function () return node.parent end do
   5	        ancestors[#ancestors + 1] = ancestor
   5	        node = ancestor
    	    end
   2	    return ancestors
    	end
    	
    	-- Print a message describing one execution path in the test scenario
    	local function printScenario (node) 
   2	    local ancestors = getAncestors(node)
   9	    for i = #ancestors, 1, -1 do
   7	        io.stderr:write(ancestors[i].description or '')
   7	        io.stderr:write('\n')
    	    end
    	end
    	
    	-- Print a message and stop the test scenario when an assertion fails
    	local function failAssert (node, description, message)
   2	    io.stderr:write(message or '')
   2	    io.stderr:write('\n\n')
   2	    printScenario(node)
   2	    io.stderr:write(description or '')
   2	    io.stderr:write('\n\n')
   2	    error(message or '')
    	end
    	
    	-- Create a branch node for a test scenario
    	test = function (node, description, process) 
 459	    node.currentNodeIndex = node.currentNodeIndex + 1
 459	    if node.currentNodeIndex == node.activeNodeIndex then
 105	        return runActiveNode(node, description, process) 
    	    end
    	end
    	
    	-- Test an assertion
    	testAssert = function (self, value, description)
 192	    if not value then
   1	        return failAssert(self, description, 'Test failed: assertion failed')
    	    end
 191	    return value
    	end
    	
    	-- Expect function f to fail
    	testError = function (self, f, description)
  15	    if pcall(f) then
   1	        return failAssert(self, description, 'Test failed: expected error')
    	    end
    	end
    	
    	-- Create the root node for a test scenario
    	local function T (description, process)
  10	    local root = createNode(nil, description, process)
    	    
  10	    runNode(root)
  73	    while root.activeNodeIndex <= #root.nodes do
  63	        local lastActiveBranch = root.lastActiveLeaf.parent
  63	        lastActiveBranch.activeNodeIndex = lastActiveBranch.activeNodeIndex + 1
  63	        runNode(root)
    	    end
    	    
  10	    return root
    	end
    	
    	-- Run any other files passed from CLI.
   1	if arg and arg[0]:gmatch('test.lua') then
   1	    _G.T = T
   9	    for i = 1, #arg do
   8	        dofile(arg[i])
    	    end
   1	    _G.T = nil
    	end
    	
   1	return T
    	

==============================================================================
./spec/base.lua
==============================================================================
    	local function checkSubSuper (T, Sub, Super)
  52	  T:assert(getmetatable(Sub).__index == Super, 
  26	  'Then the super is the index for the sub')
  52	  T:assert(Sub ~= Super,
  26	  'Then the super is not identical to the sub')
    	end
    	
    	local function checkNotCallable (T, instance)
  24	  T:error(function () instance() end, 
   8	  'Then the instance is not callable')
    	end
    	
    	local function checkConstruct (T, Class)
  36	  T('When instantiated with the default constructor', 
    	  function (T)
   4	    Class.constructor = nil
   4	    local c = Class()
   4	    checkSubSuper(T, c, Class)
   4	    checkNotCallable (T, c)
    	  end)
  36	  T('When instantiated with a custom constructor', 
    	  function (T)
   8	    function Class:constructor (x) self.x = x; return x, 45 end
   4	    local c, x, y = Class(123)
   8	    T:assert(c.x == 123,
   4	    'Then the constructor is applied to the instance')
   8	    T:assert(x == 123 and y == 45,
   4	    'Then return values from the constructor follow the instance')
   4	    checkSubSuper(T, c, Class)
   4	    checkNotCallable (T, c)
    	  end)
    	end
    	
    	local function checkExtend (T, Class)
  24	  T('When a class is extended', 
    	  function (T)
   6	    local Sub = Class:extend()
   6	    checkSubSuper(T, Sub, Class)
   6	    checkConstruct(T, Sub)
    	  end)
    	end
    	
   2	T('Given a base class', 
    	function (T)
  13	  local Base = require 'knife.base'
  26	  T('When the base class is extended with no arguments', 
    	  function (T)
   6	    local Thing = Base:extend()
   6	    checkSubSuper(T, Thing, Base)
   6	    checkConstruct(T, Thing)
   6	    checkExtend (T, Thing)
    	  end)
  26	  T('When the base class is extended with a table argument', 
    	  function (T)
   6	    local t = { x = 1 }
   6	    local Thing = Base:extend(t)
  12	    T:assert(Thing == t,
   6	    'Then the new class is identical to the table')
   6	    checkSubSuper(T, Thing, Base)
   6	    checkConstruct(T, Thing)
   6	    checkExtend (T, Thing)
    	  end)
    	end)
    	

==============================================================================
./spec/behavior.lua
==============================================================================
   2	T('Given some states', function (T)
    	
   6	    local Behavior = require 'knife.behavior'
    	
   6	    local thought = false
    	
    	    local function think (behavior, subject)
   2	        thought = true
    	    end
    	
   6	    local states = {
   6	        default = {
   6	            { sprite = 'human.idle.a', duration = 1, after = 'idle' },
   6	        },
   6	        idle = {
   6	            { sprite = 'human.idle.a', duration = 3 },
   6	            { sprite = 'human.idle.b', duration = 1 },
   6	            { sprite = 'human.idle.a', duration = 2 },
   6	            { sprite = 'human.idle.c', duration = 1, action = think },
   6	        },
   6	        walk = {
   6	            { sprite = 'human.run.a', duration = 0.2 },
   6	            { sprite = 'human.run.b', duration = 0.2 },
   6	            { sprite = 'human.run.c', duration = 0.2 },
   6	            { sprite = 'human.run.b', duration = 0.2 },
   6	        },
    	    }
    	
  12	    T('When a behavior is created', function (T)
   5	        local subject = {}
   5	        local behavior = Behavior(states, subject)
   5	        local frame = behavior.frame
  10	        T:assert(frame,
   5	        'Then the behavior has a current frame')
    	
  10	        T('When the behavior is updated by a small dt', function (T)
   1	            behavior:update(0.5)
   2	            T:assert(behavior.frame == frame,
   1	            'Then the behavior has the same frame')
    	        end)
    	
  10	        T('When the behavior is updated by a larger dt', function (T)
   1	            behavior:update(2)
   2	            T:assert(behavior.frame ~= frame,
   1	            'Then the behavior has a new frame')
    	        end)
    	
  10	        T('When the behavior encounters an action', function (T)
   1	            assert(thought == false)
   1	            behavior:update(20)
   2	            T:assert(thought == true,
   1	            'Then the action executes')
    	        end)
    	
  10	        T('When the behavior is set to a state', function (T)
   1	            behavior:setState('walk', 2)
   2	            T:assert(behavior.frame == states.walk[2],
   1	            'Then the frame is set accordingly')
    	        end)
    	
    	    end)
    	
    	end)

==============================================================================
./spec/chain.lua
==============================================================================
   2	T('Given a function taking a callback', function (T)
    	
   4	    local Chain = require 'knife.chain'
    	
    	    local function doStuff (a, b, callback)
   1	        callback(a, b)
    	    end
    	
   8	    T('When Chain factory is called', function (T)
    	
   6	        local c1 = Chain(function (go)
   1	            doStuff(2, 3, go)
    	        end)
    	
   6	        T:assert(type(c1) == 'function',
   3	        'Then a chain is created')
    	
   6	        T('When the chain is invoked with a function arg', function (T)
    	
    	            local resultA, resultB
    	
   4	            local c2 = c1(function (go, a, b)
   1	                resultA = a
   1	                resultB = b
   1	                go()
    	            end)
    	
   4	            T:assert(type(c2) == 'function' and c1 == c2,
   2	            'Then the chain is extended')
    	
   4	            T('When the chain is invoked with no args', function (T)
    	
   1	                c2()
    	
   2	                T:assert(resultA == 2 and resultB == 3,
   1	                'Then the chain is executed')
    	
    	            end)
    	
    	        end)
    	
    	    end)
    	
    	end)

==============================================================================
./spec/convoke.lua
==============================================================================
   2	T('Given convoke', function (T)
   5	    local Convoke = require 'knife.convoke'
    	
   5	    local cb = {}
    	
    	    local function go ()
  13	        for k, v in ipairs(cb) do
   8	            v()
    	        end
   5	        cb = {}
    	    end
    	
    	    local function doStuff (arg1, arg2, callback)
   8	        cb[#cb + 1] = function ()
   8	            callback(arg1, arg2)
    	        end
    	    end
    	
  10	    T('When invoked with a callback', function (T)
   2	        Convoke(function (continue, wait)
   1	            doStuff(123, 456, continue())
   1	            local r1, r2 = wait()
   2	            T:assert(r1 == 123 and r2 == 456,
   1	            'Then "wait" returns arguments passed to contination function')
    	
   1	            doStuff(234, 345, continue())
   1	            local r1, r2 = wait()
   2	            T:assert(r1 == 234 and r2 == 345,
   1	            'Then "wait" returns arguments passed to contination function x2')
   3	        end)()
    	
   1	        go()
    	    end)
    	
  10	    T('When multiple continues are present', function (T)
   2	        Convoke(function (continue, wait)
   1	            doStuff(123, 456, continue())
   1	            doStuff(234, 345, continue())
   1	            local r1, r2 = wait()
   2	            T:assert(r1 == 234 and r2 == 345,
   1	            'Then "wait" returns arguments from last invoked contination')
   3	        end)()
    	
   1	        go()
    	    end)
    	
  10	    T('When invoked with multiple callbacks', function (T)
   2	        Convoke(function (continue, wait)
   1	            doStuff(123, 456, continue())
   1	            local r1, r2 = wait()
   2	            T:assert(r1 == 123 and r2 == 456,
   1	            'Then "wait" returns arguments passed to contination function')
   3	        end)(function (continue, wait)
   1	            doStuff(234, 345, continue())
   1	            local r1, r2 = wait()
   2	            T:assert(r1 == 234 and r2 == 345,
   1	            'Then "wait" returns arguments passed to contination function x2')
   3	        end)()
    	
   1	        go()
    	    end)
    	
  10	    T('When invoked with a callback after running', function (T)
    	        local foo
    	
   2	        local c = Convoke(function (continue, wait)
   1	            doStuff(123, 456, continue())
   1	            local r1, r2 = wait()
   2	            T:assert(r1 == 123 and r2 == 456,
   1	            'Then "wait" returns arguments passed to contination function')
   1	            foo = 1
    	        end)
    	
   1	        c()
   1	        go()
    	
   1	        T:assert(foo == 1, 'Then the first callback runs')
    	
   2	        c(function (continue, wait)
   1	            doStuff(234, 345, continue())
   1	            local r1, r2 = wait()
   2	            T:assert(r1 == 234 and r2 == 345,
   1	            'Then "wait" returns arguments passed to contination function x2')
   1	            foo = 2
    	        end)
    	
   1	        go()
    	
   1	        T:assert(foo == 2, 'Then the second callback runs')
    	    end)
    	
    	end)

==============================================================================
./spec/event.lua
==============================================================================
   2	T('Given event module is loaded', function (T)
  11	    local Event = require 'knife.event'
  11	    Event.handlers = {}
    	    
  22	    T('When a handler is registered', function (T)
    	        local eventArg
  11	        local fooHandler = Event.on('foo', function (x) eventArg = x end)
    	        
  16	        T('When the event fires', function (T)
   1	            assert(eventArg == nil)
   1	            Event.dispatch('foo', 123)
   1	            T:assert(eventArg == 123, 'Then the handler runs')
    	        end)
    	        
  16	        T('When the handler is removed and the event fires', function (T)
   1	            fooHandler:remove()
   1	            assert(eventArg == nil)
   1	            Event.dispatch('foo', 123)
   1	            T:assert(eventArg == nil, 'Then the handler does not run')
    	        end)
    	            
  16	        T('When a second handler is registered', function (T)
    	            local eventArg2
   6	            local fooHandler2 = Event.on('foo', function (x) eventArg2 = x end)
    	            
   8	            T('When the event fires', function (T)
   1	                assert(eventArg == nil and eventArg2 == nil)
   1	                Event.dispatch('foo', 123)
   1	                T:assert(eventArg == 123, 'Then the first handler runs')
   1	                T:assert(eventArg2 == 123, 'Then the second handler runs')
    	            end)
    	            
   8	            T('When the first handler is removed and the event fires', function (T)
   1	                fooHandler:remove()
   1	                assert(eventArg == nil and eventArg2 == nil)
   1	                Event.dispatch('foo', 123)
   1	                T:assert(eventArg == nil, 'Then the first handler does not run')
   1	                T:assert(eventArg2 == 123, 'Then the second handler runs')
    	            end)
    	            
   8	            T('When the second handler is removed and the event fires', function (T)
   1	                fooHandler2:remove()
   1	                assert(eventArg == nil and eventArg2 == nil)
   1	                Event.dispatch('foo', 123)
   1	                T:assert(eventArg == 123, 'Then the first handler runs')
   1	                T:assert(eventArg2 == nil, 'Then the second handler does not run')
    	            end)
    	            
    	        end)
    	        
  16	        T('When a second handler returning false is registered', function (T)
    	            local eventArg2
   2	            Event.on('foo', function (x) 
   1	                eventArg2 = x
   1	                return false 
    	            end)
   1	            assert(eventArg == nil and eventArg2 == nil)
   1	            Event.dispatch('foo', 123)
   1	            T:assert(eventArg == nil, 'Then the first handler does not run')
   1	            T:assert(eventArg2 == 123, 'Then the second handler runs')
    	        end)
    	        
    	    end)
    	    
  22	    T('When dispatchers are injected into a table', function (T)
   1	        local t = { bar = true }
    	        local eventArg
   1	        Event.injectDispatchers(t)
   2	        Event.on('bar', function (x) eventArg = x end)
   1	        assert(eventArg == nil)
   1	        t.bar(123)
   1	        T:assert(eventArg == 123, 'Then members of the table dispatch events')
    	    end)
    	    
  22	    T('When dispatchers are injected into a table by key', function (T)
   1	        local t = {}
    	        local eventArg
   1	        Event.injectDispatchers(t, { 'baz' })
   2	        Event.on('baz', function (x) eventArg = x end)
   1	        assert(eventArg == nil)
   1	        t.baz(123)
   1	        T:assert(eventArg == 123, 'Then members of the table dispatch events')
    	    end)
    	    
    	end)

==============================================================================
./spec/memoize.lua
==============================================================================
   2	T('memoize', 
    	function (T)
    	    
  15	  local memoize = require 'knife.memoize'
    	
  15	  local counter = 0
    	
    	  local function count(...)
  12	    counter = counter + 1
  12	    return counter
    	  end
    	
  15	  local memoized_count = memoize(count)
    	
    	  local function switch(x,y)
   2	    counter = counter + 1
   2	    return y,x
    	  end
    	
  15	  local memoized_switch = memoize(switch)
    	
  15	  local countable = setmetatable({}, {__call = count})
  15	  local memoized_countable = memoize(countable)
    	
    	  local function count2(...)
   1	    counter = counter + 1
   1	    return counter
    	  end
    	
  30	  T("should accept ony non-callable parameters, and error otherwise", 
    	  function (T)
   2	    T:error(function() memoize() end)
   2	    T:error(function() memoize('foo') end)
   2	    T:error(function() memoize(1) end)
   2	    T:error(function() memoize({}) end)
   1	    memoize(print)
   1	    memoize(countable)
    	  end)
  30	  T("should work with 0 parameters", 
    	  function (T)
   1	    memoized_count()
   1	    T:assert(memoized_count() == 1)
   1	    T:assert(counter == 1)
    	  end)
    	
  30	  T("should work with one parameter", 
    	  function (T)
   1	    memoized_count('foo')
   1	    T:assert(memoized_count('foo') == 1)
   1	    T:assert(memoized_count('bar') == 2)
   1	    T:assert(memoized_count('foo') == 1)
   1	    T:assert(memoized_count('bar') == 2)
   1	    T:assert(counter == 2)
    	  end)
    	
  30	  T("should work with two parameters", 
    	  function (T)
   1	    memoized_count('foo', 'bar')
   1	    T:assert(memoized_count('foo', 'bar') == 1, '1')
   1	    T:assert(memoized_count('foo', 'baz') == 2, '2')
   1	    T:assert(memoized_count('foo', 'bar') == 1, '3')
   1	    T:assert(memoized_count('foo', 'baz') == 2, '4')
   1	    T:assert(counter == 2)
    	  end)
    	
  30	  T("should work with tables & functions", 
    	  function (T)
   1	    local t1 = {}
   1	    local t2 = {}
   1	    T:assert(memoized_count(print, t1) == 1)
   1	    T:assert(memoized_count(print, t2) == 2)
   1	    T:assert(memoized_count(print, t1) == 1)
   1	    T:assert(memoized_count(print, t2) == 2)
   1	    T:assert(counter == 2)
    	  end)
    	
  30	  T("should return multiple values when needed", 
    	  function (T)
   1	    local x,y = memoized_switch(100, 200)
   1	    T:assert(x == 200)
   1	    T:assert(y == 100)
   1	    T:assert(counter == 1)
   1	    x,y = memoized_switch(400, 500)
   1	    T:assert(x == 500)
   1	    T:assert(y == 400)
   1	    T:assert(counter == 2)
   1	    x,y = memoized_switch(100, 200)
   1	    T:assert(x == 200)
   1	    T:assert(y == 100)
   1	    T:assert(counter == 2)
   1	    x,y = memoized_switch(400, 500)
   1	    T:assert(x == 500)
   1	    T:assert(y == 400)
   1	    T:assert(counter == 2)
    	  end)
    	
  30	  T("should clean cache when called twice", 
    	  function (T)
   1	    memoized_count('reset')
   1	    T:assert(memoized_count('reset') == 1)
   1	    memoize(count)
   1	    T:assert(memoized_count('reset') == 2)
    	  end)
    	
  30	  T( 'callable tables', 
    	  function (T)
    	    
   8	    T("Unchanged callable tables should work just like functions", 
    	    function (T)
   1	      memoized_countable()
   1	      T:assert(memoized_countable() == 1)
   1	      T:assert(counter == 1)
   1	      memoized_countable('foo')
   1	      T:assert(memoized_countable('foo') == 2)
   1	      T:assert(counter == 2)
    	    end)
    	
   8	    T("When callable table's __call metamethod is changed, the cache is reset", 
    	    function (T)
   1	      memoized_countable('bar')
   1	      T:assert(memoized_countable('bar') == 1)
   1	      local mt = getmetatable(countable)
   1	      mt.__call = count2
   1	      memoized_countable('bar')
   1	      T:assert(memoized_countable('bar') == 2)
   1	      T:assert(memoized_countable('bar') == 2)
    	    end)
    	
   8	    T("An error is thrown if a memoized callable table loses its __call", 
    	    function (T)
   1	      local mt = getmetatable(countable)
   1	      mt.__call = nil
   2	      T:error(function() memoized_countable() end)
    	    end)
    	  end)
    	  
  30	  T("airstruck", 
    	  function (T)
    	  
   6	      T("handles nil arguments", 
    	      function (T)
    	  
    	        local function cat(a, b, c)
   4	          return tostring(a) .. tostring(b) .. tostring(c)
    	        end
    	
   1	        local memoized_cat = memoize(cat)
    	        
   1	        T:assert(memoized_cat('a', 'b', 'c') == 'abc', '1')
   1	        T:assert(memoized_cat('a', 'b', 'c') == 'abc', '2')
    	        
   1	        T:assert(memoized_cat('va', nil, 'la') == 'vanilla', '3')
   1	        T:assert(memoized_cat('va', nil, 'la') == 'vanilla', '4')
    	        
   1	        T:assert(memoized_cat('va', 'la') == 'valanil', '5')
   1	        T:assert(memoized_cat('va', 'la') == 'valanil', '6')
    	        
   1	        T:assert(memoized_cat('va') == 'vanilnil', '7')
   1	        T:assert(memoized_cat('va') == 'vanilnil', '8')
    	        
    	      end)
    	      
   6	      T("handles nil results", 
    	      function (T)
    	      
    	        local function passthrough (a, b, c)
   2	          return a, b, c
    	        end
    	
   1	        local memoized_passthrough = memoize(passthrough)
    	      
   1	        local a, b, c = memoized_passthrough('a', 'b', 'c')
   1	        T:assert(a == 'a') T:assert(b == 'b') T:assert(c == 'c')
    	        
   1	        a, b, c = memoized_passthrough('a', 'b', 'c')
   1	        T:assert(a == 'a') T:assert(b == 'b') T:assert(c == 'c')
    	        
   1	        x, y, z = memoized_passthrough('x', nil, 'z')
   1	        T:assert(x == 'x') T:assert(y == nil) T:assert(z == 'z')
    	        
   1	        x, y, z = memoized_passthrough('x', nil, 'z')
   1	        T:assert(x == 'x') T:assert(y == nil) T:assert(z == 'z')
    	        
    	      end)
    	      
    	  end)
    	
    	end)
    	

==============================================================================
./spec/system.lua
==============================================================================
   2	T('Given some systems and some entities',
    	function (T)
   9	    local System = require 'knife.system'
    	
   9	    local e1 = {
   9	        position = { x = 10, y = 20 },
    	    }
   9	    local e2 = {
   9	        position = { x = 30, y = 40 },
   9	        velocity = { x = 1, y = 2 }
    	    }
    	
  18	    local updatePosition = System(
   9	    { 'position', 'velocity' },
    	    function (pos, vel)
   2	        pos.x = pos.x + vel.x
   2	        pos.y = pos.y + vel.y
    	    end)
    	
  18	    local updateBoundary = System(
   9	    { 'position', 'velocity' },
    	    function (pos, vel)
   1	        if pos.y > 40 then
   1	            return true
    	        end
    	    end)
    	
   9	    local entities = { e1, e2 }
    	
  18	    T('When a system is invoked',
    	    function (T)
   1	        updatePosition(entities)
   2	        T:assert(entities[2].position.y == 42,
   1	        'Then the components of the entities are updated')
    	    end)
    	
  18	    T('When a system with an empty aspects list is invoked',
    	    function (T)
   1	        local counter = 0
    	
   2	        local noAspects = System({}, function ()
   2	            counter = counter + 1
    	        end)
    	
   1	        noAspects(entities)
   2	        T:assert(counter == 2,
   1	        'Then all entities are processed')
    	    end)
    	
  18	    T('When a system references a pseudo-component',
    	    function (T)
   1	        local results = {}
   2	        local pseudo = System(
   1	        { '_entity' },
    	        function (entity)
   2	            results[#results + 1] = entity
    	        end)
   1	        pseudo(entities)
   2	        T:assert(results[1] == e1 and results[2] == e2,
   1	        'Then the pseudo-component is available to the process')
    	    end)
    	
  18	    T('When a process returns true',
    	    function (T)
   1	        assert(#entities == 2)
   1	        updatePosition(entities)
   1	        updateBoundary(entities)
   2	        T:assert(#entities == 1 and entities[1] == e1,
   1	        'Then the current entity is removed')
    	    end)
    	
  18	    T('When a process returns a number',
    	    function (T)
    	
   2	        local testRemovalByIndex = System(
   1	        { 'position' },
    	        function (pos)
   2	            return 1
    	        end)
    	
   1	        assert(#entities == 2)
   1	        testRemovalByIndex(entities)
   2	        T:assert(#entities == 1 and entities[1] == e2,
   1	        'Then the corresponding entity is removed')
    	    end)
    	
  18	    T('When a process returns a table',
    	    function (T)
    	
   2	        local testRemovalByIndices = System(
   1	        { 'position' },
    	        function (pos)
   2	            return { 1, 2 }
    	        end)
    	
   1	        assert(#entities == 2)
   1	        testRemovalByIndices(entities)
   2	        T:assert(#entities == 0,
   1	        'Then the corresponding entities are removed')
    	    end)
    	
  18	    T('When a process returns an invalid removal value',
    	    function (T)
    	
   2	        local testRemovalError = System(
   1	        { 'position' },
    	        function (pos)
   1	            return 'x'
    	        end)
    	
   3	        T:error(function () testRemovalError(entities) end,
   1	        'Then an error is thrown')
    	    end)
    	
  18	    T('When a process returns new entities',
    	    function (T)
    	
   1	        local e3 = {
   1	            position = { x = 1, y = 2 },
   1	            velocity = { x = 2, y = 1 }
    	        }
    	
   2	        local addStuff = System(
   1	        { 'position', 'velocity' },
    	        function (pos, vel)
   1	            return false, { e3 }
    	        end)
    	
   1	        assert(#entities == 2)
   1	        addStuff(entities)
   2	        T:assert(entities[3] == e3,
   1	        'Then the new entities are added')
    	    end)
    	
    	end)

==============================================================================
./spec/test.lua
==============================================================================
   2	T('Given an empty table', 
    	function (T)
   6	  local t = {}
  12	  T('When an item is inserted into a table', 
    	  function (T)
   5	    assert(#t == 0)
   5	    table.insert(t, 111)
   5	    T:assert(#t == 1, 'Then the size of the table is 1')
   5	    T:assert(t[1] == 111, 'Then the item is stored in index 1')
    	    
  10	    T('When the index is set to nil', 
    	    function (T)
   1	      assert(#t == 1)
   1	      t[1] = nil
   1	      T:assert(#t == 0, 'Then the size of the table is 0')
   2	        pcall(function ()
   2	            T:error(function () end, 'THIS TEST INTENTIONALLY FAILS')
    	        end)
    	    end)
    	    
  10	    T('When another item is inserted', 
    	    function (T)
   3	      assert(#t == 1)
   3	      table.insert(t, 222)
   3	      T:assert(#t == 2, 'Then the size of the table is 2')
   3	      T:assert(t[2] == 222, 'Then the second item is stored in index 2')
    	
   6	      T('When the first item is removed with table.remove', 
    	      function (T)
   1	        assert(#t == 2)
   1	        table.remove(t, 1)
   1	        T:assert(#t == 1, 'Then the size of the table is 1')
   1	        T:assert(t[1] == 222, 'Then the second item has moved to index 1')
    	      end)
    	      
   6	      T('When the first item is set to nil', 
    	      function (T)
   1	        assert(#t == 2)
   1	        t[1] = nil
   1	        T:assert(#t == 2, 'Then the size of the table is 2')
   1	        T:assert(t[2] == 222, 'Then the second item remains in index 2')
   2	        pcall(function () 
   1	            T:assert(false, 'THIS TEST INTENTIONALLY FAILS') 
    	        end)
    	      end)
    	    end)
    	    
    	  end)
    	end)
    	
   2	T('Given a value of two', function (T)
   3	  local value = 2
   6	  T('When the value is increased by five', function (T)
    	    -- here, value is 2
   1	    value = value + 5
   1	    local foo = 10
   1	    T:assert(value == 7 and foo == 10, 'Then the value equals seven')
    	  end)
   6	  T('When the value is decreased by five', function (T)
    	    -- value is 2 again; this test is isolated from the "increased by five" test
   1	    value = value - 5
   1	    T:assert(value == -3, 'Then the value equals negative three')
    	  end)
    	end)
    	
   2	T('Given a value of two', function (T)
   1	  local value = 2
   1	  T:assert(value == 2, 'Then the value equals two')
    	end)

==============================================================================
Summary
==============================================================================

8	0	100.00%	./knife/base.lua
40	0	100.00%	./knife/behavior.lua
11	0	100.00%	./knife/chain.lua
25	0	100.00%	./knife/convoke.lua
36	0	100.00%	./knife/event.lua
43	0	100.00%	./knife/memoize.lua
78	0	100.00%	./knife/system.lua
62	0	100.00%	./knife/test.lua
39	0	100.00%	./spec/base.lua
43	0	100.00%	./spec/behavior.lua
19	0	100.00%	./spec/chain.lua
60	0	100.00%	./spec/convoke.lua
55	0	100.00%	./spec/event.lua
111	0	100.00%	./spec/memoize.lua
74	0	100.00%	./spec/system.lua
42	0	100.00%	./spec/test.lua
------------------------
746	0	100.00%	
